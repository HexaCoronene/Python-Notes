# Effective Python

`__author__ = Brett Slatkin`

---

## 第 1 章：用 Pythonic 方式来思考

### 第 1 条：[确认自己所用的 Python 版本](用Pythonic方式来思考/第1条：确认自己所用的Python版本.md)

### 第 2 条：[遵循 PEP8 风格指南](用Pythonic方式来思考/第2条：遵循 PEP8 风格指南.md)

### 第 3 条：[了解 bytes、str 与 unicode 的区别](用Pythonic方式来思考/第3条：了解bytes、str与unicode的区别.md)

### 第 4 条：[用辅助函数来取代复杂的表达式](用Pythonic方式来思考/第4条：用辅助函数来取代复杂的表达式.md)

### 第 5 条：[了解切割序列的方法](用Pythonic方式来思考/第5条：了解切割序列的方法.md)

### 第 6 条：[在单次切片操作中，不要同时指定 start、end 和 stride](用Pythonic方式来思考/第6条：在单次切片操作中，不要同时指定start、end和stride.md)

### 第 7 条：用列表推导来取代 map 和 filter

### 第 8 条：不要使用含有两个以上表达式的列表推导

### 第 9 条：用生成器表达式来改写数据量较大的列表推导

### 第 10 条：尽量用 enumerate 取代 range

### 第 11 条：用 zip 函数同时遍历两个迭代器

### 第 12 条：不要在 for 和 while 循环后面写 else 块

### 第 13 条：合理利用 try/except/else/finally 结构中的每个代码块

---

## 第 2 章：函数

### 第 14 条：尽量用异常来表示特殊情况，而不要返回 None

### 第 15 条：了解如何在闭包力使用外围作用域中的变量

### 第 16 条：考虑用生成器来改写直接返回列表的函数

### 第 17 条：在参数上面迭代时，要多加小心

### 第 18 条：用数量可变的位置参数减少视觉杂讯

### 第 19 条：用关键字参数来表达可选的行为

### 第 20 条：用 None 和文档字符串来描述具有动态默认值的参数

### 第 21 条：用只能以关键字指定的参数来确保代码清晰

---

## 第 3 章：类与继承

### 第 22 条：尽量用辅助类来维护程序的状态，而不要用字典和元组

### 第 23 条：简单的借口应该接受函数，而不是类的实例

### 第 24 条：以 @classmethod 形式的多态去通用地构建对象

### 第 25 条：用 super 初始化父类

### 第 26 条：只在使用 Mix-in 组件制作工具链时进行多重继承

### 第 27 条：多用 public 属性，少用 private 属性

### 第 28 条：继承 collections.abc 以实现自定义的容器类型

---

## 第 4 章：元类及属性

### 第 29 条：用纯属性取代 get 和 set 方法

### 第 30 条：考虑用 @property 来代替属性重构

### 第 31 条：用描述符来改写需要复用的 @property 方法

### 第 32 条：用 \_\_getattr__ 、\_\_getattribute__  和 \_\_setattr 实现按需生成的属性

### 第 33 条：用元类来验证子类

### 第 34 条：用元类来注册子类

### 第 35 条：用元类来注解类的属性

---

## 第 5 章：并发及并行

### 第 36 条：用 subprocess 模块来管理子进程

### 第 37 条：可以用线程来执行阻塞式 I/O，但不要用它做平行计算

### 第 38 条：在线程中使用 Lock 来防止数据竞争

### 第 39 条：用 Queue 来协调各线程之间的工作

### 第 40 条：考虑用协程来并发地运行多个函数

### 第 41 条：考虑用 concurrent.futures 来实现真正的平行计算

---

## 第 6 章：内置模块

### 第 42 条：[用 functools.wraps 定义函数装饰器](内置模块\第42条：用functools.wraps定义函数修饰器.md)

### 第 43 条：考虑以 contextlib 和 with 语句来改写可复用的 try/finally 代码

### 第 44 条：用 copyreg 实现可操作的 pickle 操作

### 第 45 条：应该用 datetime 模块来处理本地时间，而不是用 time 模块

### 第 46 条：使用内置算法和数据结构

### 第 47 条：在重视精确度的场合，应该使用 decimal

### 第 48 条：学会安装由 Python 开发者社区所构建的模块

---

## 第 7 章：协作开发

### 第 49 条：为每个函数、类和模块编写文档字符串

### 第 50 条：用包来安装模块，并提供稳固的 API

### 第 51 条：为自编的模块定义根异常，以便将调用者与 API 相隔离

### 第 52 条：用适当的方式打破循环依赖关系

### 第 53 条：用虚拟环境隔离项目，并重建其依赖关系

---

## 第 8 章：部署

### 第 54 条：考虑用模块级别的代码来配置不同的部署环境

### 第 55 条：通过 repr 字符串来输出调试信息

### 第 56 条：用 unittest 来测试全部代码

### 第 57 条：考虑用 pdb 实现交互测试

### 第 58 条：先分析性能，然后再优化

### 第 59 条：用 tracemalloc 来掌握内存的使用及泄露情况